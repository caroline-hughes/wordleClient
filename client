#!/usr/bin/env python3
from array import array
import sys, argparse, logging, socket, json

# send a message over the socket
def sendMessage(s: socket, messageToSend: object):
  print('\nsending:', messageToSend)
  msg = (json.dumps(messageToSend) + "\n").encode()
  totalBytesSent = 0
  while totalBytesSent < len(msg):
      # help from: https://docs.python.org/3/howto/sockets.html
      nextSent = s.send(msg[totalBytesSent:])
      if nextSent == 0:
          raise RuntimeError("lost socket connection")
      totalBytesSent = totalBytesSent + nextSent

# receieve a message over the socket
def receieveMessage(s: socket):
  buffer = ''
  try:
      while "\n" not in buffer: 
          data = s.recv(1024).decode('utf-8')
          # help from: https://stackoverflow.com/questions/55922194/python-breaks-string-after-first-character
          if not data:
              break
          buffer += data
  except Exception as loopException:
      print("Exception occurred in loop, exiting...", loopException)

  res = json.loads(buffer)
  print('\nreceived:', res)

  # guard against other messages than those of expected types
  if res['type'] != 'start' and res['type'] != 'retry' and res['type'] != 'bye' and res['type'] != 'error':
    print("\nrecieved invalid message type, closing connection\n")
    s.close()

  return res

# the loop for choosing a guess, listening for the response, and 
# modifying the words list before the next guess based on the marks of the previous guesses
def runGuessLoop(s, id, wlist):
  wordsList = wlist
  res = {}
  count = 0

  # while it's the first guess or no previous guess has been correct
  while res == {} or res['type'] != 'bye':

    # filter words array based on incorrect guesses
    if res != {}:
      curGuess = res['guesses'][count]['word']
      guessMarks: array = res['guesses'][count]['marks']
      count += 1

      for index, mark in enumerate(guessMarks):
        if mark == 0 or mark == 1:
          wordsList = list(filter(lambda w: w[index] != curGuess[index], wordsList))
        if mark == 1:
          wordsList = list(filter(lambda w: w.find(curGuess[index]) != -1, wordsList))
        if mark == 2:
          wordsList = list(filter(lambda w: w[index] == curGuess[index], wordsList))
    
    # guess the first in words array
    guess = {"type": "guess", "id": id, "word": wordsList[0]}
    sendMessage(s, guess)

    try:
      res = receieveMessage(s) # listen for response
    except:
      print('\ncouldnt get guess response')


def client(args, loglevel):
  logging.basicConfig(format="%(levelname)s: %(message)s", level=loglevel)

  # text file --> array of strings
  wordsfile = open("project1-words.txt", "r")
  wordsList = wordsfile.read().split('\n')
  wordsfile.close()

  # print(args)
  # print('Argument List:', str(sys.argv), '\n')

  useTLS = bool(args.tls)
  port = int(args.p)  

  # need better way to do this
  if sys.argv.count("-s") > 0:
    sys.argv.remove('-s')

  if sys.argv.count("-p") > 0:
    sys.argv.remove('-p')
    sys.argv.remove(args.p)

  host = sys.argv[1]
  username = sys.argv[2]

  print('host:', host)
  print('username:', username)
  print('port:', port)
  print('tls?', useTLS)

  # create an INET, STREAMing socket
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((host, port))

  # HELLO
  try:
    hello = {"type": "hello", "northeastern_username": "hughes.ca"}
    sendMessage(s, hello)
  except:
    print('\ncouldnt send first msg')

  # START
  try:  
    connectionID = receieveMessage(s)['id']
  except:
    print('\ncouldnt get start res')

  # GUESS LOOP
  runGuessLoop(s, connectionID, wordsList)


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Lets play wordle.')
  parser.add_argument('-s', dest='tls', action='store_true')
  parser.set_defaults(tls=False)
  parser.add_argument(
                      "-p",
                      metavar="PORT",
                      default=27993,
                      help="pass -p with your TLS port")

  # specifies the name of the server (either a DNS name or an IP address in dotted notation)
  parser.add_argument('hostname', type=str, nargs=1, help='the hostname')

  parser.add_argument('Northeastern-username', type=str, nargs=1, help='your Northeastern username')
  args = parser.parse_args()
  
  loglevel = logging.INFO
  
  client(args, loglevel)