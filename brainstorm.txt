all lowercase, all 5 chars

can be stateless, you recieve your guesses in the json each 'retry'

500 max guesses... cant straight up brute

use library for encoding/parsing json

server runs on proj1.3700.network

--> optional params:

If the -s parameter is given to your program,
it should connect to the server using an encrypted TLS socket 
and then complete the protocol normally (i.e., hello, start, guess, retry, and bye)

You may assume that the serverâ€™s TLS port is 27994,
unless the port is overridden on the command line using the -p option.

$ ./client <-p port> <-s> <hostname> <Northeastern-username>

Each message is an ASCII string consisting of multiple fields separated by spaces (0x20) 
and terminated with a line feed (0x0A, \n). 
Messages are case sensitive.

the server may send corrupted messages just to try and crash your software. 
If a received message is not as expected, such as an incorrect field or wrong message type, 
you must assert an error and terminate your program.


like, when u recieve their json, check that is must be one of
case type:
  start
  retry
  bye
default
  error


The protocol works as follows. 
The client initiates the protocol by creating a TCP socket connection to the server. 
  how? lmao

Once the socket is connected, the client sends a hello message to the server.


eg

C -> S: {"type": "hello", "northeastern_username": "amislove"}\n
S -> C: {"type": "start", "id": "foo"}\n
C -> S: {"type": "guess", "id": "foo", "word": "treat"}\n
S -> C: {"type": "retry", "id": "foo", "guesses": [{ "word": "treat", "marks": [1, 0, 2, 2, 0]}]}\n
C -> S: {"type": "guess", "id": "foo", "word": "sweat"}\n
S -> C: {"type": "retry", "id": "foo", "guesses": [{ "word": "treat", "marks": [1, 0, 2, 2, 0]}, { "word": "sweat", "marks": [2, 0, 2, 2, 1]}]}\n
C -> S: {"type": "guess", "id": "foo", "word": "steam"}\n
S -> C: {"type": "bye", "id": "foo", "flag": "sndk83nb5ks&*dk*SKDFHGk"}\n

